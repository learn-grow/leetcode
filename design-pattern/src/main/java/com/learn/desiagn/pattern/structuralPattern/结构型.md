#1.代理模式
    定义:由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
    模式的结构
    代理模式的主要角色如下。
    1 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    2 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
    3 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
    
    使用场景:
    1 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
    2 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
    3 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
    智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
    4 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。
    

#2.适配器模式 Adapter Pattern
    定义:将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作,
    适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。
    
    结构
    1 抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    2 真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象
    3 代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能
    
    实现方式：通过继承
    
    结构：
    1 目标接口 target：当前系统业务所期待的接口，它可以是抽象类或接口。
    2 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
    3 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。
    
    使用场景：
    适配器模式（Adapter）通常适用于以下场景。
    1 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
    2 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

#3.桥接模式 Bridge Pattern
    定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
    优点:
    由于抽象与实现分离，所以扩展能力强；
    其实现细节对客户透明。
    缺点:
    由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。
    
    使用场景:
    1 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
    2 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
    3 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。

#4.装饰者模式 Decorator Pattern
    定义:指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。
    模式的结构
    装饰模式主要包含以下角色。
    1 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
    2 具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
    3 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
    4 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
    
    使用场景：
    当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。
    当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。
    当对象的功能要求可以动态地添加，也可以再动态地撤销时。


    
#5.外观模式 Facade Pattern

    定义:是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
    外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。

    1. 模式的结构

    外观（Facade）模式包含以下主要角色。

    1.外观（Facade）角色：为多个子系统对外提供一个共同的接口。

    2.子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。

    3.客户（Client）角色：通过一个外观角色访问各个子系统的功能。
    
    使用场景：
    1 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
    2 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
    3 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。
#6.享元模式


#7.组合模式