#1.模板方法模式 template method
    定义:定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式
    结构:
    1 抽象类(abstract class):负责给出一个算法的轮廓和骨架,它由一个模板方法喝若干个基本方法构成
      1) 模板方法：定义了算法的骨架，按照某种顺序调用其包含的基本方法
      2) 基本方法：是整个算法中的一个步骤：
        .抽象方法:在抽象中申明,由具体子类实现
        .具体方法:在抽象中已经实现,在具体子类中可以继承或重写它
        .钩子方法:在抽象类中已经实现,包括用于判断的逻辑方法和需要子类重写的空方法两种
        
    2 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。
    
    使用场景:
    1 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
    2 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
    3 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。
    
    

#2.策略模式  Strategy pattern

    定义:定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。
    
    结构:
    1 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
    2 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
    3 环境（Context）类：持有一个策略类的引用，最终给客户端调用。
    
    使用场景:
    1 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。
    2 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。
    3 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。
    4 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。
    5 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

#3.命令模式 command pattern
    定义:将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。
    
    结构:
    1 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。
    2 具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
    3 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
    4 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。
    
    使用场景:
    1 当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。
    2 当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。
    3 当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。
    4 当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。
    

#4.责任链模式  Chain of Responsibility pattern
    定义:为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
    
    结构:
    1 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
    2 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
    3 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

#5.状态模式 state pattern
    定义:对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
    
    结构:
    1 环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
    2 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
    3 具体状态（Concrete    State）角色：实现抽象状态所对应的行为。

#6.观察者模式

#7.中介者模式

#8.迭代器模式

#9.访问者模式

#10.备忘录模式

#11.解释器模式

