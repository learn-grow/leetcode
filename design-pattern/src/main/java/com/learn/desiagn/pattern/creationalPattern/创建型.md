#1.简单工厂模式（Simple Factory Pattern）
1 使用者只需要给工厂类传入正确的约定参数，就可以获取所需要的对象,不需要知道其中创建的细节,一定程度上减少系统的耦合。

2 客户端不需要知道所创建的具体产品的类名，只需要知道具体产品类别所对应的参数即可，减少开发者的记忆成本

#2.工厂方法模式（Factory Method Pattern）
优点

1 用户只关心其所需产品的对应的具体工厂是哪一个就可以了，不需要关心产品的细节，也不需要知道具体产品类的名称
2 当系统加入新产品时，不需要修改抽象工厂和抽象产品所提供的接口，客户端和其他的具体的工厂与具体产品，只是添加一个具体工厂和其对应具体产品就可以了，符合了开闭原则

缺点

1 当系统中加入新产品时，除了需要提供新的产品类之外，还要提供与其对应的具体工厂类，因此系统类中类的个数将成对增加，增加了系统的复杂度

#3.抽象工厂模式（Abstract Factory Pattern）

优点:

1 具体产品在应用层代码隔离，不需要关心产品细节，只需要知道自己需要的产品是属于那个工厂即可，当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象，这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式

缺点

1 规定了所有可能创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的方法。

#4.单例模式（Singleton Pattern）

优点：

1 提供了对唯一实例的受控访问，因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。

2 因为该类在系统内存中只存在一个对象，节约系统资源

缺点

1 没有抽象层，很难扩展

2 对于java 而言，如果对象长时间不被利用，则可能被GC回收，那么如果这个单例持有一些数据，在回收后重新实例化时就不复存在了。

#5.生成器模式（Builder Pattern）创建者模式

优点

1 客户端不必关心产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象

2 每一个具体建造者相对独立，与其他建造者无关,因此可以很方便的替换具体建造者或者新增新的建造者，用户使用不同的建造者得到不同的对象

3 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者编程，系统扩展方便，符合开闭原则

4 可以更加精细化的控制产品的创建过程，将复杂的创建步骤分解到不同的方法中，使得创建过程更加清晰，也更方便使用程序开控制创建过程

缺点

1 建造者模式所创建的产品一般具有较多的共同点，其组成部分相识，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制

2 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大


#6.原型模式（Prototype Pattern）
java中克隆技术，以某个对象为原型，复制出新的对象，显然新的对象具备原型对象的特点

优点

1 效率高(直接克隆,避免了重新执行构造过程步骤)

2 克隆类似于new，但不同与new，new创建对象的值采用的是默认值，克隆出的对象属性完全和原型对象相同，并且克隆出的新对象改变不会影响原型对象，然后再修改克隆对应的值。


原型模式很少单独使用，一般是和工厂模式一起使用，通过clone方法创建一个对象，然后由工厂模式提供给调用者